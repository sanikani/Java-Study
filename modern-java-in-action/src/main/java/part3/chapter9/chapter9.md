## Chapter 
#### 내용
- 람다 표현식으로 코드 리팩터링
- 람다 표현식이 객체 지향 설계에 미치는 영향
- 람다 표현식 테스팅
- 람다 표현식과 스트림 API 사용 코드 디버깅
#### 가독성과 유연성을 개선하는 리팩터링
- 람다 표현식은 익명 클래스보다 간결하다
- 메서드 참조를 이용하면 더 간결하다
- 동작 파라미터화를 지원하므로 더 큰 유연성을 가져 다양한 요구사항 변화에 대응할 수 있다
- 익명 클래스에서 this는 익명 클래스 자신, 람다에서 this는 람다를 감싸는 클래스
- 람다 표현식 내부에서는 변수 가리기가 허용되지 않음
- 익명 클래스는 인스턴스화 할 때 명시적으로 형식이 정해지는 반면 람다의 형식은 콘텍스트에 따라 달라지기 때문에 모호하다. 명시적 형변환을 이용해서 모호함을 제거할 수 있다
- 람다 표현식을 별도의 메서드로 추출한 다음에 메서드 참조를 사용하여 인수로 전달할 수 있다
- comparing과 maxBy 같은 정적 헬퍼 메서드를 활용하는 것도 좋다
- 매번 같은 준비, 종료 과정을 반복적으로 수행하는 코드가 있다면 이를 람다로 변환할 수 있다.
#### 람다로 객체지향 디자인 패턴 리팩터링
- 전략, 템플릿 메서드, 옵저버, 의무 체인, 팩토리
  
**전략 패턴**
- 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법
- 전략 패턴은 세 부분으로 구성됨
    - 알고리즘을 나타내는 인터페이스
    - 다양한 알고리즘을 나타내는 한 개 이상의 인터페이스 구현
    - 전략 객체를 사용하는 한 개 이상의 클라이언트
- 적절한 알고리즘을 선택하기 위해 함수형 인터페이스의 인스턴스 생성 시 람다 표현식을 사용하면 간결한 코드 작성 가능
  
**템플릿 메서드 패턴**
- 알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때 사용
  
**옵저버 패턴**
- 어떤 이벤트가 발생했을 때 한 객체(주제)가 다른 객체 리스트(옵저버)에 자동으로 알림을 보내야 하는 상황에서 사용
- 실행해야 하는 동작이 비교적 간단한 경우에는 람다 표현식으로 불필요한 코드를 제거하는 것이 바람직하다
- 하지만 옵저버가 상태를 가지며, 여러 메서드를 정의하는 등 복잡하다면 람다 표현식보다 기존의 클래스 구현방식을 고수하는 것이 바람직할 수도 있다
  
**의무 체인**
- 작업 처리 객체의 체인 등을 만들 때 사용
- 한 객체가 어떤 작업을 처리한 다음에 다른 객체로 결과를 전달하고, 다른 객체도 해야 할 작업을 처리한 다음에 또 다른 객체로 전달하는 식
  
**팩토리**
- 인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 사용